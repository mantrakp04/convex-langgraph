/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export const URL = "https://api.machines.dev/v1";

export enum MainStatusCode {
  Unknown = "unknown",
  CapacityErr = "insufficient_capacity",
}

export enum FlyUnhealthyPolicy {
  UnhealthyPolicyStop = "stop",
}

export enum FlyContainerHealthcheckScheme {
  HTTP = "http",
  HTTPS = "https",
}

export enum FlyContainerHealthcheckKind {
  Readiness = "readiness",
  Liveness = "liveness",
}

export enum FlyContainerDependencyCondition {
  ExitedSuccessfully = "exited_successfully",
  Healthy = "healthy",
  Started = "started",
}

export interface App {
  id?: string;
  name?: string;
  organization?: Organization;
  status?: string;
}

export interface AppSecret {
  digest?: string;
  name?: string;
  value?: string;
}

export interface AppSecrets {
  secrets?: AppSecret[];
}

export interface AppSecretsUpdateRequest {
  values?: Record<string, string>;
}

export interface AppSecretsUpdateResp {
  secrets?: AppSecret[];
  version?: number;
}

export interface CheckStatus {
  name?: string;
  output?: string;
  status?: string;
  updated_at?: string;
}

export interface CreateAppDeployTokenRequest {
  expiry?: string;
}

export interface CreateAppRequest {
  app_name?: string;
  enable_subdomains?: boolean;
  network?: string;
  org_slug?: string;
}

export interface CreateAppResponse {
  token?: string;
}

export interface CreateLeaseRequest {
  description?: string;
  /** seconds lease will be valid */
  ttl?: number;
}

export interface CreateMachineRequest {
  /** An object defining the Machine configuration */
  config?: FlyMachineConfig;
  lease_ttl?: number;
  lsvd?: boolean;
  min_secrets_version?: number;
  /** Unique name for this Machine. If omitted, one is generated for you */
  name?: string;
  /** The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you). */
  region?: string;
  skip_launch?: boolean;
  skip_secrets?: boolean;
  skip_service_registration?: boolean;
}

/** Optional parameters */
export interface CreateOIDCTokenRequest {
  /** @example "https://fly.io/org-slug" */
  aud?: string;
  aws_principal_tags?: boolean;
}

export interface CreateVolumeRequest {
  compute?: FlyMachineGuest;
  compute_image?: string;
  encrypted?: boolean;
  fstype?: string;
  name?: string;
  region?: string;
  require_unique_zone?: boolean;
  size_gb?: number;
  /** restore from snapshot */
  snapshot_id?: string;
  snapshot_retention?: number;
  /** fork from remote volume */
  source_volume_id?: string;
  unique_zone_app_wide?: boolean;
}

export interface CurrentTokenResponse {
  tokens?: MainTokenInfo[];
}

export interface DecryptSecretkeyRequest {
  associated_data?: number[];
  ciphertext?: number[];
}

export interface DecryptSecretkeyResponse {
  plaintext?: number[];
}

export interface DeleteAppSecretResponse {
  version?: number;
}

export interface DeleteSecretkeyResponse {
  version?: number;
}

export interface EncryptSecretkeyRequest {
  associated_data?: number[];
  plaintext?: number[];
}

export interface EncryptSecretkeyResponse {
  ciphertext?: number[];
}

export interface ErrorResponse {
  /** Deprecated */
  details?: any;
  error?: string;
  status?: MainStatusCode;
}

export interface ExtendVolumeRequest {
  size_gb?: number;
}

export interface ExtendVolumeResponse {
  needs_restart?: boolean;
  volume?: Volume;
}

export interface IPAssignment {
  created_at?: string;
  ip?: string;
  region?: string;
  service_name?: string;
  shared?: boolean;
}

export interface ImageRef {
  digest?: string;
  labels?: Record<string, string>;
  registry?: string;
  repository?: string;
  tag?: string;
}

export interface Lease {
  /** Description or reason for the Lease. */
  description?: string;
  /** ExpiresAt is the unix timestamp in UTC to denote when the Lease will no longer be valid. */
  expires_at?: number;
  /** Nonce is the unique ID autogenerated and associated with the Lease. */
  nonce?: string;
  /** Owner is the user identifier which acquired the Lease. */
  owner?: string;
  /** Machine version */
  version?: string;
}

export interface ListApp {
  id?: string;
  machine_count?: number;
  name?: string;
  network?: any;
  volume_count?: number;
}

export interface ListAppsResponse {
  apps?: ListApp[];
  total_apps?: number;
}

export interface ListenSocket {
  address?: string;
  proto?: string;
}

export interface Machine {
  checks?: CheckStatus[];
  config?: FlyMachineConfig;
  created_at?: string;
  events?: MachineEvent[];
  host_status?: "ok" | "unknown" | "unreachable";
  id?: string;
  image_ref?: ImageRef;
  incomplete_config?: FlyMachineConfig;
  /** InstanceID is unique for each version of the machine */
  instance_id?: string;
  name?: string;
  /** Nonce is only every returned on machine creation if a lease_duration was provided. */
  nonce?: string;
  /** PrivateIP is the internal 6PN address of the machine. */
  private_ip?: string;
  region?: string;
  state?: string;
  updated_at?: string;
}

export interface MachineEvent {
  id?: string;
  request?: any;
  source?: string;
  status?: string;
  timestamp?: number;
  type?: string;
}

export interface MachineExecRequest {
  /** Deprecated: use Command instead */
  cmd?: string;
  command?: string[];
  container?: string;
  stdin?: string;
  timeout?: number;
}

export interface MachineVersion {
  user_config?: FlyMachineConfig;
  version?: string;
}

export interface Organization {
  name?: string;
  slug?: string;
}

export interface ProcessStat {
  command?: string;
  cpu?: number;
  directory?: string;
  listen_sockets?: ListenSocket[];
  pid?: number;
  rss?: number;
  rtime?: number;
  stime?: number;
}

export interface SecretKey {
  name?: string;
  public_key?: number[];
  type?: string;
}

export interface SecretKeys {
  secret_keys?: SecretKey[];
}

export interface SetAppSecretRequest {
  value?: string;
}

export interface SetAppSecretResponse {
  digest?: string;
  name?: string;
  value?: string;
  version?: number;
}

export interface SetSecretkeyRequest {
  type?: string;
  value?: number[];
}

export interface SetSecretkeyResponse {
  name?: string;
  public_key?: number[];
  type?: string;
  version?: number;
}

export interface SignSecretkeyRequest {
  plaintext?: number[];
}

export interface SignSecretkeyResponse {
  signature?: number[];
}

export interface SignalRequest {
  signal?:
    | "SIGABRT"
    | "SIGALRM"
    | "SIGFPE"
    | "SIGHUP"
    | "SIGILL"
    | "SIGINT"
    | "SIGKILL"
    | "SIGPIPE"
    | "SIGQUIT"
    | "SIGSEGV"
    | "SIGTERM"
    | "SIGTRAP"
    | "SIGUSR1";
}

export interface StopRequest {
  signal?: string;
  timeout?: FlyDuration;
}

export interface UpdateMachineRequest {
  /** An object defining the Machine configuration */
  config?: FlyMachineConfig;
  current_version?: string;
  lease_ttl?: number;
  lsvd?: boolean;
  min_secrets_version?: number;
  /** Unique name for this Machine. If omitted, one is generated for you */
  name?: string;
  /** The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you). */
  region?: string;
  skip_launch?: boolean;
  skip_secrets?: boolean;
  skip_service_registration?: boolean;
}

export interface UpdateVolumeRequest {
  auto_backup_enabled?: boolean;
  snapshot_retention?: number;
}

export interface VerifySecretkeyRequest {
  plaintext?: number[];
  signature?: number[];
}

export interface Volume {
  attached_alloc_id?: string;
  attached_machine_id?: string;
  auto_backup_enabled?: boolean;
  block_size?: number;
  blocks?: number;
  blocks_avail?: number;
  blocks_free?: number;
  bytes_total?: number;
  bytes_used?: number;
  created_at?: string;
  encrypted?: boolean;
  fstype?: string;
  host_status?: "ok" | "unknown" | "unreachable";
  id?: string;
  name?: string;
  region?: string;
  size_gb?: number;
  snapshot_retention?: number;
  state?: string;
  zone?: string;
}

export interface VolumeSnapshot {
  created_at?: string;
  digest?: string;
  id?: string;
  retention_days?: number;
  size?: number;
  status?: string;
}

export interface AssignIPRequest {
  network?: string;
  org_slug?: string;
  region?: string;
  service_name?: string;
  type?: string;
}

export interface FlyContainerConfig {
  /** CmdOverride is used to override the default command of the image. */
  cmd?: string[];
  /**
   * DependsOn can be used to define dependencies between containers. The container will only be
   * started after all of its dependent conditions have been satisfied.
   */
  depends_on?: FlyContainerDependency[];
  /** EntrypointOverride is used to override the default entrypoint of the image. */
  entrypoint?: string[];
  /** ExtraEnv is used to add additional environment variables to the container. */
  env?: Record<string, string>;
  /** EnvFrom can be provided to set environment variables from machine fields. */
  env_from?: FlyEnvFrom[];
  /**
   * Image Config overrides - these fields are used to override the image configuration.
   * If not provided, the image configuration will be used.
   * ExecOverride is used to override the default command of the image.
   */
  exec?: string[];
  /** Files are files that will be written to the container file system. */
  files?: FlyFile[];
  /** Healthchecks determine the health of your containers. Healthchecks can use HTTP, TCP or an Exec command. */
  healthchecks?: FlyContainerHealthcheck[];
  /** Image is the docker image to run. */
  image?: string;
  /** Name is used to identify the container in the machine. */
  name?: string;
  /**
   * Restart is used to define the restart policy for the container. NOTE: spot-price is not
   * supported for containers.
   */
  restart?: FlyMachineRestart;
  /**
   * Secrets can be provided at the process level to explicitly indicate which secrets should be
   * used for the process. If not provided, the secrets provided at the machine level will be used.
   */
  secrets?: FlyMachineSecret[];
  /** Stop is used to define the signal and timeout for stopping the container. */
  stop?: FlyStopConfig;
  /** UserOverride is used to override the default user of the image. */
  user?: string;
}

export interface FlyContainerDependency {
  condition?: "exited_successfully" | "healthy" | "started";
  name?: string;
}

export interface FlyContainerHealthcheck {
  exec?: FlyExecHealthcheck;
  /** The number of times the check must fail before considering the container unhealthy. */
  failure_threshold?: number;
  /** The time in seconds to wait after a container starts before checking its health. */
  grace_period?: number;
  http?: FlyHTTPHealthcheck;
  /** The time in seconds between executing the defined check. */
  interval?: number;
  /** Kind of healthcheck (readiness, liveness) */
  kind?: FlyContainerHealthcheckKind;
  /** The name of the check. Must be unique within the container. */
  name?: string;
  /** The number of times the check must succeeed before considering the container healthy. */
  success_threshold?: number;
  tcp?: FlyTCPHealthcheck;
  /** The time in seconds to wait for the check to complete. */
  timeout?: number;
  /** Unhealthy policy that determines what action to take if a container is deemed unhealthy */
  unhealthy?: FlyUnhealthyPolicy;
}

export interface FlyDNSConfig {
  dns_forward_rules?: FlyDnsForwardRule[];
  hostname?: string;
  hostname_fqdn?: string;
  nameservers?: string[];
  options?: FlyDnsOption[];
  searches?: string[];
  skip_registration?: boolean;
}

export interface FlyDuration {
  "time.Duration"?:
    | -9223372036854776000
    | 9223372036854776000
    | 1
    | 1000
    | 1000000
    | 1000000000
    | 60000000000
    | 3600000000000;
}

/** EnvVar defines an environment variable to be populated from a machine field, env_var */
export interface FlyEnvFrom {
  /**
   * EnvVar is required and is the name of the environment variable that will be set from the
   * secret. It must be a valid environment variable name.
   */
  env_var?: string;
  /** FieldRef selects a field of the Machine: supports id, version, app_name, private_ip, region, image. */
  field_ref?: "id" | "version" | "app_name" | "private_ip" | "region" | "image";
}

export interface FlyExecHealthcheck {
  /** The command to run to check the health of the container (e.g. ["cat", "/tmp/healthy"]) */
  command?: string[];
}

/** A file that will be written to the Machine. One of RawValue or SecretName must be set. */
export interface FlyFile {
  /**
   * GuestPath is the path on the machine where the file will be written and must be an absolute path.
   * For example: /full/path/to/file.json
   */
  guest_path?: string;
  /** The name of an image to use the OCI image config as the file contents. */
  image_config?: string;
  /** Mode bits used to set permissions on this file as accepted by chmod(2). */
  mode?: number;
  /** The base64 encoded string of the file contents. */
  raw_value?: string;
  /** The name of the secret that contains the base64 encoded file contents. */
  secret_name?: string;
}

export interface FlyHTTPHealthcheck {
  /** Additional headers to send with the request */
  headers?: FlyMachineHTTPHeader[];
  /** The HTTP method to use to when making the request */
  method?: string;
  /** The path to send the request to */
  path?: string;
  /** The port to connect to, often the same as internal_port */
  port?: number;
  /** Whether to use http or https */
  scheme?: FlyContainerHealthcheckScheme;
  /** If the protocol is https, the hostname to use for TLS certificate validation */
  tls_server_name?: string;
  /** If the protocol is https, whether or not to verify the TLS certificate */
  tls_skip_verify?: boolean;
}

export interface FlyHTTPOptions {
  compress?: boolean;
  h2_backend?: boolean;
  headers_read_timeout?: number;
  idle_timeout?: number;
  response?: FlyHTTPResponseOptions;
}

export interface FlyHTTPResponseOptions {
  headers?: Record<string, any>;
  pristine?: boolean;
}

export interface FlyMachineCheck {
  /** The time to wait after a VM starts before checking its health */
  grace_period?: FlyDuration;
  headers?: FlyMachineHTTPHeader[];
  /** The time between connectivity checks */
  interval?: FlyDuration;
  /** Kind of the check (informational, readiness) */
  kind?: "informational" | "readiness";
  /** For http checks, the HTTP method to use to when making the request */
  method?: string;
  /** For http checks, the path to send the request to */
  path?: string;
  /** The port to connect to, often the same as internal_port */
  port?: number;
  /** For http checks, whether to use http or https */
  protocol?: string;
  /** The maximum time a connection can take before being reported as failing its health check */
  timeout?: FlyDuration;
  /** If the protocol is https, the hostname to use for TLS certificate validation */
  tls_server_name?: string;
  /** For http checks with https protocol, whether or not to verify the TLS certificate */
  tls_skip_verify?: boolean;
  /** tcp or http */
  type?: string;
}

export interface FlyMachineConfig {
  /** Optional boolean telling the Machine to destroy itself once it’s complete (default false) */
  auto_destroy?: boolean;
  /** An optional object that defines one or more named top-level checks. The key for each check is the check name. */
  checks?: Record<string, FlyMachineCheck>;
  /**
   * Containers are a list of containers that will run in the machine. Currently restricted to
   * only specific organizations.
   */
  containers?: FlyContainerConfig[];
  /** Deprecated: use Service.Autostart instead */
  disable_machine_autostart?: boolean;
  dns?: FlyDNSConfig;
  /** An object filled with key/value pairs to be set as environment variables */
  env?: Record<string, string>;
  files?: FlyFile[];
  guest?: FlyMachineGuest;
  /** The docker image to run */
  image?: string;
  init?: FlyMachineInit;
  metadata?: Record<string, string>;
  metrics?: FlyMachineMetrics;
  mounts?: FlyMachineMount[];
  processes?: FlyMachineProcess[];
  /** The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/. */
  restart?: FlyMachineRestart;
  schedule?: string;
  services?: FlyMachineService[];
  /** Deprecated: use Guest instead */
  size?: string;
  /**
   * Standbys enable a machine to be a standby for another. In the event of a hardware failure,
   * the standby machine will be started.
   */
  standbys?: string[];
  statics?: FlyStatic[];
  stop_config?: FlyStopConfig;
}

export interface FlyMachineGuest {
  cpu_kind?: string;
  cpus?: number;
  gpu_kind?: string;
  gpus?: number;
  host_dedication_id?: string;
  kernel_args?: string[];
  memory_mb?: number;
}

/** For http checks, an array of objects with string field Name and array of strings field Values. The key/value pairs specify header and header values that will get passed with the check call. */
export interface FlyMachineHTTPHeader {
  /** The header name */
  name?: string;
  /** The header value */
  values?: string[];
}

export interface FlyMachineInit {
  cmd?: string[];
  entrypoint?: string[];
  exec?: string[];
  kernel_args?: string[];
  swap_size_mb?: number;
  tty?: boolean;
}

export interface FlyMachineMetrics {
  https?: boolean;
  path?: string;
  port?: number;
}

export interface FlyMachineMount {
  add_size_gb?: number;
  encrypted?: boolean;
  extend_threshold_percent?: number;
  name?: string;
  path?: string;
  size_gb?: number;
  size_gb_limit?: number;
  volume?: string;
}

export interface FlyMachinePort {
  end_port?: number;
  force_https?: boolean;
  handlers?: string[];
  http_options?: FlyHTTPOptions;
  port?: number;
  proxy_proto_options?: FlyProxyProtoOptions;
  start_port?: number;
  tls_options?: FlyTLSOptions;
}

export interface FlyMachineProcess {
  cmd?: string[];
  entrypoint?: string[];
  env?: Record<string, string>;
  /** EnvFrom can be provided to set environment variables from machine fields. */
  env_from?: FlyEnvFrom[];
  exec?: string[];
  /**
   * IgnoreAppSecrets can be set to true to ignore the secrets for the App the Machine belongs to
   * and only use the secrets provided at the process level. The default/legacy behavior is to use
   * the secrets provided at the App level.
   */
  ignore_app_secrets?: boolean;
  /**
   * Secrets can be provided at the process level to explicitly indicate which secrets should be
   * used for the process. If not provided, the secrets provided at the machine level will be used.
   */
  secrets?: FlyMachineSecret[];
  user?: string;
}

/** The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/. */
export interface FlyMachineRestart {
  /** GPU bid price for spot Machines. */
  gpu_bid_price?: number;
  /** When policy is on-failure, the maximum number of times to attempt to restart the Machine before letting it stop. */
  max_retries?: number;
  /**
   * * no - Never try to restart a Machine automatically when its main process exits, whether that’s on purpose or on a crash.
   * * always - Always restart a Machine automatically and never let it enter a stopped state, even when the main process exits cleanly.
   * * on-failure - Try up to MaxRetries times to automatically restart the Machine if it exits with a non-zero exit code. Default when no explicit policy is set, and for Machines with schedules.
   * * spot-price - Starts the Machine only when there is capacity and the spot price is less than or equal to the bid price.
   */
  policy?: "no" | "always" | "on-failure" | "spot-price";
}

/** A Secret needing to be set in the environment of the Machine. env_var is required */
export interface FlyMachineSecret {
  /**
   * EnvVar is required and is the name of the environment variable that will be set from the
   * secret. It must be a valid environment variable name.
   */
  env_var?: string;
  /**
   * Name is optional and when provided is used to reference a secret name where the EnvVar is
   * different from what was set as the secret name.
   */
  name?: string;
}

export interface FlyMachineService {
  autostart?: boolean;
  /**
   * Accepts a string (new format) or a boolean (old format). For backward compatibility with older clients, the API continues to use booleans for "off" and "stop" in responses.
   * * "off" or false - Do not autostop the Machine.
   * * "stop" or true - Automatically stop the Machine.
   * * "suspend" - Automatically suspend the Machine, falling back to a full stop if this is not possible.
   */
  autostop?: "off" | "stop" | "suspend";
  /** An optional list of service checks */
  checks?: FlyMachineServiceCheck[];
  concurrency?: FlyMachineServiceConcurrency;
  force_instance_description?: string;
  force_instance_key?: string;
  internal_port?: number;
  min_machines_running?: number;
  ports?: FlyMachinePort[];
  protocol?: string;
}

export interface FlyMachineServiceCheck {
  /** The time to wait after a VM starts before checking its health */
  grace_period?: FlyDuration;
  headers?: FlyMachineHTTPHeader[];
  /** The time between connectivity checks */
  interval?: FlyDuration;
  /** For http checks, the HTTP method to use to when making the request */
  method?: string;
  /** For http checks, the path to send the request to */
  path?: string;
  /** The port to connect to, often the same as internal_port */
  port?: number;
  /** For http checks, whether to use http or https */
  protocol?: string;
  /** The maximum time a connection can take before being reported as failing its health check */
  timeout?: FlyDuration;
  /** If the protocol is https, the hostname to use for TLS certificate validation */
  tls_server_name?: string;
  /** For http checks with https protocol, whether or not to verify the TLS certificate */
  tls_skip_verify?: boolean;
  /** tcp or http */
  type?: string;
}

export interface FlyMachineServiceConcurrency {
  hard_limit?: number;
  soft_limit?: number;
  type?: string;
}

export interface FlyProxyProtoOptions {
  version?: string;
}

export interface FlyStatic {
  guest_path: string;
  index_document?: string;
  tigris_bucket?: string;
  url_prefix: string;
}

export interface FlyStopConfig {
  signal?: string;
  timeout?: FlyDuration;
}

export interface FlyTCPHealthcheck {
  /** The port to connect to, often the same as internal_port */
  port?: number;
}

export interface FlyTLSOptions {
  alpn?: string[];
  default_self_signed?: boolean;
  versions?: string[];
}

export interface FlyDnsForwardRule {
  addr?: string;
  basename?: string;
}

export interface FlyDnsOption {
  name?: string;
  value?: string;
}

export interface Flydv1ExecResponse {
  exit_code?: number;
  exit_signal?: number;
  stderr?: string;
  stdout?: string;
}

export interface ListIPAssignmentsResponse {
  ips?: IPAssignment[];
}

export interface MainGetPlacementsRequest {
  /** Resource requirements for the Machine to simulate. Defaults to a performance-1x machine */
  compute?: FlyMachineGuest;
  /**
   * Number of machines to simulate placement.
   * Defaults to 0, which returns the org-specific limit for each region.
   */
  count?: number;
  /** @example "personal" */
  org_slug: string;
  /**
   * Region expression for placement as a comma-delimited set of regions or aliases.
   * Defaults to "[region],any", to prefer the API endpoint's local region with any other region as fallback.
   * @example "lhr,eu"
   */
  region?: string;
  /** @example "" */
  volume_name?: string;
  volume_size_bytes?: number;
  /**
   * Optional weights to override default placement preferences.
   * @example {"region":1000,"spread":0}
   */
  weights?: PlacementWeights;
}

export interface MainGetPlacementsResponse {
  regions?: PlacementRegionPlacement[];
}

export interface MainRegionResponse {
  regions?: ReadsGetCapacityPerRegionRow[];
}

export interface MainTokenInfo {
  apps?: string[];
  org_slug?: string;
  organization?: string;
  /** Machine the token is restricted to (FromMachine caveat) */
  restricted_to_machine?: string;
  /** Machine making the request */
  source_machine_id?: string;
  token_id?: string;
  /** User identifier if token is for a user */
  user?: string;
}

export interface PlacementRegionPlacement {
  /**
   * Hint on the number of machines in this region can be created concurrently.
   * Equal to the number of unique hosts selected for placement.
   */
  concurrency?: number;
  count?: number;
  region?: string;
}

export type PlacementWeights = Record<string, number>;

export interface ReadsGetCapacityPerRegionRow {
  capacity?: number;
  code?: string;
  gateway_available?: boolean;
  geo_region?: string;
  latitude?: number;
  longitude?: number;
  name?: string;
  requires_paid_plan?: boolean;
}
